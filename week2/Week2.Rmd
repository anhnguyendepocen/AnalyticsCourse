---
title: 'Week 2: Exploratory Data Analysis/Intro to SQL'
author: "Ted Laderas"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
---

## Learning Objectives

- **Learn** the basics of exploratory analysis
- **Learn** how to read `skimr` output
- **Learn** how to interpret `visdat` output
- **Learn** the basics of SQL queries

## Exploratory Data Analysis

If we're given data, we will need to discover what's in the data. 

Our overall goal in Exploratory Data Analysis is to assess whether we can use the available data for our task.

We are going to examine the `patient` table in our database.

## Data Dictionaries

The best case scenario is if someone gives us a *data dictionary* for our dataset. The data dictionary will tell us lots of important information.

## Tools for exploring your data

We've seen one tool already for understanding what is in a `data.frame`: `summary()`. 

Now that we have the data loaded, we can confirm some properties of the data. Let's do a `summary()` first to get a basic idea of what the data looks like. How many patients are High risk versus Normal Risk? (Hint: look at the `riskCat` field.)

```{r}
library(RSQLite)
library(here)
library(tidyverse)
library(janitor)
#start our connection to the database
con <- DBI::dbConnect(RSQLite::SQLite(), here("data/patient1.sqlite"))

patient <- tbl(src=con, from="patient")
patient_all <- collect(patient)

summary(patient_all)
```

Huh. One thing to notice is that there are `numeric` variables and `character` variables. That seems kind of limited. Why is this so?


## Datatypes in SQLite

SQLite, the database system we're using, only has five datatypes:

- `NULL`. The value is a NULL value.
- `INTEGER`. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.
- `REAL`. The value is a floating point value, stored as an 8-byte IEEE floating point number.
- `TEXT`. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).
- `BLOB`. The value is a blob of data, stored exactly as it was input.

This means that there are no explicit ways to represent categorical data in SQLite, just the TEXT representation. So to actually do useful exploratory statistics on our tables, we'll need to *cast* our some of our variables as `factor`s, which are how R represents categorical data.



## Which variables are categories?

You might ask what variables are categorical ones. We'll have to guess, but there are a few that might be categories based on the previous summary.

We're going to cast `GENDER`, `PCP`, `race`, `postalcode`, `riskCat`, and `source` variables as `factor`s. We'll use the `mutate()` verb in `dplyr` to process these variables in place.

```{r}
patient_all <- patient_all %>% 
  dplyr::mutate(GENDER=factor(GENDER), 
                race=factor(race), facility=factor(facility),
                riskCat=factor(riskCat), PCP=factor(PCP), 
                postalcode=factor(postalcode), 
                source=factor(source))
```



Now, if we run our `summary()`, we get much more useful information:

```{r}
summary(patient_all)
```



## skimr

Another useful package for exploring data is `skimr`. The `skimr` package has a function called `skim()` that is very useful for summarizing data as well.

```{r}
skimr::skim(patient_all)
```



## visdat

One tool I like to use to assess patterns of missingness is the `visdat` package. The `vis_dat()` function will display the data graphically, where each horizontal line of the graphic corresponds to a row in our `data.frame`.

Because we're on Rstudio.cloud, there are memory limitations. We can't generate a visual summary for all of the rows in our data. We will have to *sample* the data somehow.

Here, we look at the first 2000 rows using the `[]` (bracket) operator on `patient_all`. 

table[rows, columns]

the `1:2000` is called a `sequence`. It means return all of the values from 1 to 2000 in order as a vector. We will use this vector as an `index` to refer to rows in our table.

So by doing `patient_all[1:2000,]`, we are saying we want the first 2000 rows of `patient_all`.

```{r}
#a sequence
1:10

visdat::vis_dat(patient_all[1:2000,])
```


### Think about it

How would we return the first five *columns* of `patient_all`?

Another approach is to use the `sample()` function to randomly sample rows from our table. We can randomly sample rows from our matrix by selecting row numbers from random. Try this out:

```{r}
sample(1:10, 5)
```

We know we can get the number of rows by `nrow()`. So we can randomly sample from our rows by doing the following.

```{r}
all_rows <- 1:nrow(patient_all)
sampled_rows <- sample(x= all_rows, size = 2000)
visdat::vis_dat(patient_all[sampled_rows,])
```



## Diving Deeper into Individual Variables

In order to access the individual columns, we can use the `$` operator to do operation on the individual columns. Here I'm running a simple `tabyl()` (from the `janitor` package) operation to count the number of rows within each category for the `riskCat` variable.

```{r}
patient_all %>%
  tabyl(riskCat)
  
```

Try out `tabyl()` on the `First_name` category. Are the results what you expected?

```{r}
patient_all %>%
  tabyl(First_name)
```

To save you some time, I'm going to show you a trick to run `table()` on all of the columns. `lapply()` is a function that we can use to apply the `table()` function to all of the columns. The output isn't super elegant, but it can help you dive into the data.

```{r}
lapply(patient_all[, -1], table)
```



## Summarizing our findings - putting together a data dictionary

We'll have to fend for ourselves with this dataset and start to put together a data dictionary for our database.

Here's what we know so far.



### Data Dictionary: patient table

- *patientid* - identifier of patient
- *GENDER* - gender of patient. Values: male or female.
- *First_name* - first name of patient - appears to be redacted. Values: Gill or Gilly. 
- *Last_name* - last name of patient - appears to be redacted. Values: Doe
- *DOB* - Date of Birth, appears to be redacted. Values: missing
- *age* - Numeric - appears to be redacted. Values: missing
- *status* - Unsure what this is. Values: 4 
- *PCP* - Appears to be the primary care provider id. Value: 14
- *CM_ID* - missing.
- *referraldate* - missing.
- *Insurance_ID* - ID of insurance company. Values: 3
- *race* - Numerical code of race. Values: ranges from 1 to 7.
- *postalcode* - Zipcode of patient. Values: 97035 to 97203.
- *riskCat* - Apparently a risk categorization. Values: High or Normal.
- *riskScore* - A rating of how risky a patient is. Values: 1 to 7.
- *deleted* - Deletion status. Values: 0.
- *date_deleted* - Date patient record is deleted. Not provided.
- *facility* - Facility patient recieved at. Values: 500.
- *source* - Patient source. Values: "deid".



## Part 2: Running a Simple Query

Let's start to use SQL (Structured Query Language). SQL is the language for searching and manipulating data in databases. Writing good SQL queries will always be a useful skill no matter what field you decide to go into.

Let's ask a simple question about the `patient` table. How many female patients are there? There are two ways we can do this. The first would be to select those patients that are female with a `SELECT` statement, return those patients as a `data.frame`, and then just count the number of rows in the `data.frame`.

Here we use another form of the `tbl()` function. The `src` (source) argument is our connection, but our `from` argument is our SQL.


```{r}
# SQL to return all columns from patient table
# where Gender is female
sqlStatement <- "SELECT * from patient WHERE Gender == 'Female'"

femalePatients <- tbl(src=con, from=sql(sqlStatement))

femalePatients <- collect(femalePatients)

nrow(femalePatients)
```


## `COUNT`

Or, we can combine our statement with `count` statement from above and get the answer directly.

```{r}
#note that for matching strings, we have to use single quotes in our SQL
#statement. Otherwise, R gets confused where the statement begins or ends.
sqlStatement <- "SELECT COUNT(*) FROM patient WHERE Gender == 'Female'"

numberFemalePatients <- tbl(src=con, from=sql(sqlStatement))

numberFemalePatients
```


## `AND`

If we wanted the number of Female patients with a normal `riskCat`, we can chain these queries using `AND`.:

```{r}
#Again, enclosing strings within single quotes so we don't confuse R
sqlStatement <- 
  "SELECT count(*) FROM patient WHERE GENDER == 'Female' 
                  AND riskCat == 'Normal'"

numberFemaleNormalPatients <- tbl(con, sql(sqlStatement))

numberFemaleNormalPatients
```


## `SELECT`ing columns

If we only wanted a few columns from the table (such as `patientid`, `GENDER` and `riskCat`), we can change our select statement to only return these columns:

```{r}
sqlStatement <- "SELECT patientid, GENDER, riskCat FROM patient 
            WHERE GENDER == 'Female' AND riskCat == 'Normal'"

selectResults <- dbGetQuery(con, sqlStatement)

selectResults[1:10,]
```

## Wrapping Up

Don't forget to Disconnect!

```{r}
dbDisconnect(con)
```


## Assignment 2

Please refer to `week2Submission.Rmd` for the assignment and how to submit it.