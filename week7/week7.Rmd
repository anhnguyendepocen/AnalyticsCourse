---
title: 'Week 7: Visualization'
author: "Ted Laderas" 
date: "`r Sys.Date()`"
output: html_notebook
---

```{r setup, include=FALSE}
library(readr)
library(lubridate)
library(ggplot2)
library(dplyr)
library(here)
```

This week we will try to understand the kinds of readmissions that are in our dataset. We're going to start with the analytic table we built in Assignment 5 and use some tools within R to do this. 


## Learning Objectives

- Use `dplyr` commands to subset our table, and add new variables to it
- Understand the concept of a `pipe` (`%>%`) and how it can simplify our code
- Learn simple plotting with `ggplot2`
- Summarize our data using `group_by()` and `summarize()` for a different kind of plot

## Loading the data in

I'm providing you with a version of the `analytic` table we calculated in weeks 5/6 so we can do some visualization as `analytic.csv`, in comma separated value format. We'll take our analytic table and load it as a `data.frame` in R using the `readr` package.

```{r}
analytic_table <- readr::read_csv(here("data/analytic.csv"))
head(analytic_table)
```

Some things to notice: `readr::read_delim()` is smart enough to recognize dates from the formatting, and makes `Admit_date` and `Discharge_date` into the `<date>` format. However, there's a few columns in the table that we want to change the format of so they will be easier to work with. We're going to change the type of `encounter_type`, `outcome`, `Admit_source`, `indexadmit` and `Readmit30` variables to be `factor`, which is R's version of categorical variables. This will help us a lot when we are visualizing and filtering the data.

We can do this by providing an argument to `col_types` about the data types we want to specify for each category. We do this by using the `cols()` function and specifying a named argument for each columns. For each column, we want to specify the value of, we need to name it and specify using a `col_` function what datatype we want to specify it as. There's five that are really useful to us: 

+ `col_logical()` (for TRUE/FALSE variables) 
+ `col_integer()` (for count variables)
+ `col_character()` (for strings)
+ `col_double()` (for decimals)
+ `col_factor()` (for factors)

Here we're using `col_factor()` to specify the following columns to be factors. We need to specify a `NULL` argument so it will guess the categories (which are called *levels*) for our variables. Otherwise, we'd have to specify every level for every variable.

```{r}
analytic_table <- readr::read_csv(here::here("data/analytic.csv"), 
                                    col_types = cols(
                                      encounter_type = col_factor(NULL),
                                      outcome = col_factor(NULL),
                                      Admit_source= col_factor(NULL),
                                      indexadmit = col_factor(NULL),
                                      Readmit30 = col_factor(NULL)
                                    ))

head(analytic_table)
```

## What is the tidyverse?

The `tidyverse` is a set of packages for manipulating, modeling, and visualizing data.

Specifically, we're going to look a the following packages:

- `dplyr` (data manipulation package)
- `lubridate` (date formatting package)
- `ggplot2` (data visualization package)

The common format that all of these packages use is the `data.frame` format. That means we can use them to manipulate, format, and visualize our `analytic_table`.

## The `filter()` function

The `filter()` function allows us to subset the data. In our case, because our table has multiple values for each patient, that means we're going to overcount our patient.

We know that each patient has one row where `indexadmit` is 1 (which is the index case), so we're going to filter our data to only have those subrows.

```{r}
filter(analytic_table, indexadmit == 1)
```

## The concept of a pipe

We're going to introduce another bit of `dplyr` syntax, the `%>%` operator. `%>%` is called the `pipe` operator. You can think of it as being similar to the `+` in a `ggplot2` statement.

What `%>%` does is that it takes the output of one statement and makes it the input of the next statement. When I'm describing it, I think of it as a "THEN". For example, I read the following expression:

```{r eval=FALSE}
analytic_table %>% filter(indexadmit ==1) 
```
As: 
- I took the `analytic_table` data, 
- THEN  I `filter`ed it down with the `indexadmit == 1"` criteria 

Note that `filter()` doesn't have a `data` argument, because the `data` is `piped` into `filter()`. Note that the output of everything in a pipe chain has to be a `data_frame`.

`%>%` allows you to chain multiple verbs in the `tidyverse`. It's one of the most powerful things about the `tidyverse`. 

## Calculating length of stay using `mutate()`

Here I'm calculating the `length_of_stay` using the `mutate()` function, which lets me calculate a new variable based on the other variables. 

If we look at our new table, we can see we have a new variable called `length_of_stay`. What data type is it?

Try writing a sentence that describes what this statement does.

```{r}
analytic_table <- analytic_table %>% 
  filter(indexadmit ==1) %>%
  mutate(length_of_stay = Discharge_date - Admit_date) 

head(analytic_table)
```

## Extracting the month from discharge date

One other quantity we want to extract is the month the date is discharged. Using the `month()` function in the lubridate package, we can extract the month from a `date` variable. 

So we're going to take the output of the above codeblock (which includes the `length_of_stay` variable), and then add another variable using `mutate`.

Take a look at the `discharge_month` variable. What data type is it?

```{r}
analytic_table <- analytic_table %>%
  mutate(discharge_month = month(Discharge_date))

head(analytic_table)
```

## An overview of the data

Okay, we've manipulated our data. But are our manipulations correct? 

The `glimpse` function, from the `dplyr` package, is a useful tool to look at a `data.frame`:

```{r}
glimpse(analytic_table)
```

## What is a statistical graphic?

Ok, now that we're happy with our `analytic_table` we can finally get to visualizing it with a statistical graphic!

What is a statistical graphic? Well, to quote Chester Ismay, a statistical graphic consists of the following:

### A `mapping` of `data` variables
### to `aes()`thetic attributes
### of `geom_`etric objects.

We'll go over this in detail with an example below.

## Your first `ggplot`

We're just going to summarize `analytic_table` in terms of a couple variables first. The first thing we'll generate is a bar plot of the `Readmit30` variables.

```{r}
 bar_plot1 <-  ggplot(data=analytic_table, 
                      mapping=aes(x=Readmit30)) + 
               geom_bar()

 bar_plot1
```

Let's talk about the `data` and `mapping` arguments first. The `data` argument is our `data.frame()` of interest: `analytic_table`. Things get a little more interesting with the `mapping` argument. Let's take it apart:

```
aes(x=Readmit30)
```

The `aes()` function will return a mapping of the variables in our `data.frame` to the aesthetic properties of our plot. Within that mapping, we see that we are mapping the `Readmit30` column to the `x` aesthetic, which corresponds to the the x-axis. 

The `geom_bar()` is the actual *geometric layout* that we are going to display the data on. If you look at the documentation for `geom_bar()` (`?geom_bar`) you can see that the geometic layout contains the following aesthetics that can be mapped:

+ x
+ y
+ alpha
+ colour
+ fill
+ group
+ linetype
+ size

Only the `x` variable is required for `geom_bar`. Here's a list of all of the geoms: https://ggplot2.tidyverse.org/reference/#section-layer-geoms There are a lot of geoms, but many of them are specialized. 

The other thing to notice is that we chain the `ggplot()` and `geom_bar()` statements with a `+` sign. The strength of `ggplot2` is the fact that you can layer multiple datasets and multiple types of visualizations as layers on the ggplot. 

Note that we can't interchange `%>% and `+`. This is confusing, but for right now, understand that `%>%` is for manipulating `data.frame`s and `+` is for connecting concepts in our plots.

## Getting more complicated: adding a `fill` aesthetic

We can get more complicated with mapping a variable to the fill aesthetic: 

```{r}
 bar_plot1 <-  ggplot(data=analytic_table, 
                      mapping=aes(x=Readmit30, fill=Admit_source)) + 
               geom_bar(color="black")

 bar_plot1
```

Try removing the `color="black"` argument. What happens to the plot?

## Proportional Plots

We may just want to understand whether the proportion of emergency room admits is different for our readmission cases compared to the other cases. In this case, we can use a stacked proportional barplot:

```{r}
 bar_plot1 <-  ggplot(data=analytic_table, 
                      mapping=aes(x=Readmit30, fill=Admit_source)) + 
               geom_bar(color="black", position="fill")

 bar_plot1
```

## Adding a title

Take a look at the documentation for `ggtitle()` (`?ggtitle`). How do you add a title to a graph?

## Working with Time

We can manipulate dates using the `lubridate` package. Here I'm using the `month()` function to only use the month on our x-axis.

```{r}
ggplot(data=analytic_table, mapping = aes(x=month(Discharge_date), fill=Admit_source)) + geom_bar(color="black")
```

## Showing a histogram of length of stay

Since `length_of_stay` is a numeric variable, we can plot it as a histogram: 

```{r warning=FALSE}
hist_stay <- ggplot(data=analytic_table, mapping = aes(x=length_of_stay)) + geom_histogram(bins = 120, color="black") +  
  ggtitle("Histogram of length of hospital stay")

hist_stay
```

A powerful technique is called *faceting*, where we stratify a plot based on a category. 

Amazingly, `ggplot` lets us do this by adding a single statement, `facet_wrap`. We can add `facet_wrap` and specify what variable we want to stratify one.

```{r warning=FALSE}
hist_stay <- ggplot(data=analytic_table, mapping = aes(x=length_of_stay)) + geom_histogram(bins = 120, color="black") +  
  ggtitle("Histogram of length of hospital stay") + 
  facet_wrap(facets= "Admit_source")

hist_stay
```

Take a look at the `x` and `y` axes. Are the scales identical for each plot?

## Visualizing the data in a different way

Heatmaps are another way we could visualize the data, where we plot the data as a grid, and where the fill color of the box corresponds to a quantity.

If we want to do this, we'll need to *summarize* the data across the categories we're interested in.

We want to plot counts of `discharge_month` versus the `Admit_source`. We can do this by using the `group_by()`/`summarize()` pattern. Since we want our summary table to be summarized by `discharge_month` and `Admit_source`, we use `group_by()`. 

`group_by()` splits the data into the separate categories so we can do some sort of `summarize()` option. We might want to take the `mean` of the values, we might want to take the `median`, or in our case, we want the *count*, which is done by using the `n()` function. 

```{r}
analytic_table_summarized <- analytic_table %>% 
  mutate(discharge_month = month(Discharge_date)) %>% 
  group_by(discharge_month, Admit_source) %>%
  summarize(discharge_count = n()) 

analytic_table_summarized
```

This code takes a little bit to unpack. The first thing to note, is that we're mapping three variables from our `analytic_table_summarized`: `discharge_month`, which is on the x axis, `Admit_source`, which is on the y axis, and `discharge_count`, which is mapped to fill.

We're now going add the `geom_tile()` geom to our data, which will lay it out in a grid.

The last bit lets us add a color scale to our fill parameter. We're specifying that we want low values to be represented by `white` and high values to be represented by `red`. The `breaks` argument will let us bin different numbers into different color categories. Here, we're specifying three numbers, which means our color will be represented by 4 different bins (0-100, 101-1000, etc).

```{r}
ggplot(data=analytic_table_summarized, 
       mapping = aes(x=discharge_month, y=Admit_source, 
                     fill=discharge_count)) + 
  # lay the data out as a tile
  geom_tile(color = "black") + 
  scale_fill_gradient(low="white", high="red", breaks=c( 100, 1000, 5000)) 
```

Ok, that's a little abstract. And the legend is kind of distracting. We're going to add the `geom_text()` geom, and provide a mapping to of `discharge_count` to the `label` aesthetic.

Then we're going to remove the legend by using `theme()`. We won't go into `theme` too much this week, but we'll see it is really important when we want to reduce clutter when presenting our graphs.

```{r}
heatmap_analytic <- ggplot(data=analytic_table_summarized, 
       mapping = aes(x=discharge_month, y=Admit_source, 
                     fill=discharge_count)) + 
  # lay the data out as a tile
  geom_tile(color = "black") + 
  scale_fill_gradient(low="white", high="red", breaks=c( 100, 1000, 5000)) +
  geom_text(aes(label=discharge_count), color="black") + 
  #remove the legend
  theme(legend.position = "none")

heatmap_analytic
```

In the final problem, we'll have you tweak the colors of the scale. Maybe you can find a better one than `red`.

## Putting Plots together: `patchwork`

Now we can start grouping our plots together. `patchwork` is good about scaling plots with common units to be on the same scale as the others.

```{r}
library(patchwork)

combined_graph <- hist_stay + heatmap_analytic + 
  #specify the plot layout - 1 column, and with 
  #height of hist_stay to be 3 times larger than bar_plot1
  plot_layout(ncol=1, heights = c(3,1))

combined_graph
```

Try playing around with combinations of the plots we've done. Does doing a combination of information help us?

You can learn more about arranging plots using `patchwork` on the `patchwork` readme: https://github.com/thomasp85/patchwork/blob/master/README.md 

## For More Info

The [R-bootcamp](http://r-bootcamp.netlify.com) covers `dplyr` (chapter 3) and `ggplot2` (chapter 1 and 2) in much more detail if you want to learn more.


 